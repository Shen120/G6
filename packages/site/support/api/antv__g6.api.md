## API Report File for "@antv/g6"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AABB } from '@antv/g';
import { Animation as Animation_2 } from '@antv/g';
import { Canvas } from '@antv/g';
import { CircleStyleProps } from '@antv/g';
import { CircularLayout as CircularLayout_2 } from '@antv/layout';
import type { CircularLayoutOptions } from '@antv/layout';
import { ComboCombinedLayout } from '@antv/layout';
import { ConcentricLayout as ConcentricLayout_2 } from '@antv/layout';
import type { ConcentricLayoutOptions } from '@antv/layout';
import { CubeGeometryProps } from '@antv/g-plugin-3d';
import { Cursor } from '@antv/g';
import { D3ForceLayout as D3ForceLayout_2 } from '@antv/layout';
import type { D3ForceLayoutOptions } from '@antv/layout';
import { DagreLayout } from '@antv/layout';
import { DataURLType } from '@antv/g';
import { DisplayObject } from '@antv/g';
import { Edge } from '@antv/graphlib';
import { EllipseStyleProps } from '@antv/g';
import EventEmitter from '@antv/event-emitter';
import { FederatedPointerEvent } from '@antv/g';
import { ForceAtlas2Layout } from '@antv/layout';
import type { ForceAtlas2LayoutOptions } from '@antv/layout';
import { ForceLayout as ForceLayout_2 } from '@antv/layout';
import type { ForceLayoutOptions } from '@antv/layout';
import { FruchtermanLayout as FruchtermanLayout_2 } from '@antv/layout';
import type { FruchtermanLayoutOptions } from '@antv/layout';
import { Graph as Graph_2 } from '@antv/graphlib';
import { Graph as Graph_3 } from 'types';
import { GraphChange } from '@antv/graphlib';
import { GraphData as GraphData_2 } from 'types';
import { GridLayout as GridLayout_2 } from '@antv/layout';
import type { GridLayoutOptions } from '@antv/layout';
import { Group } from '@antv/g';
import { HTMLStyleProps } from '@antv/g';
import { IAnimation } from '@antv/g';
import { IAnimationEffectTiming } from '@antv/g';
import { ID } from '@antv/graphlib';
import { ID as ID_2 } from 'types';
import { ID as ID_3 } from '@antv/graphlib/lib/types';
import { IEdge } from 'types/edge';
import { ImageStyleProps } from '@antv/g';
import { ImageStyleProps as ImageStyleProps_2 } from '@antv/gui/lib/shapes';
import type { LayoutMapping } from '@antv/layout';
import * as Layouts from '@antv/layout';
import { LineStyleProps } from '@antv/g';
import { MDSLayout as MDSLayout_2 } from '@antv/layout';
import type { MDSLayoutOptions } from '@antv/layout';
import { Node as Node_2 } from '@antv/graphlib';
import { PathStyleProps } from '@antv/g';
import { PlainObject } from '@antv/graphlib';
import { PlaneGeometryProps } from '@antv/g-plugin-3d';
import { Point as Point_2 } from '@antv/g';
import { PointLike } from '@antv/g';
import { PolygonStyleProps } from '@antv/g';
import { PolylineStyleProps } from '@antv/g';
import { RadialLayout as RadialLayout_2 } from '@antv/layout';
import type { RadialLayoutOptions } from '@antv/layout';
import { RandomLayout as RandomLayout_2 } from '@antv/layout';
import type { RandomLayoutOptions } from '@antv/layout';
import { RectStyleProps } from '@antv/g';
import { SphereGeometryProps } from '@antv/g-plugin-3d';
import { TextStyleProps } from '@antv/g';
import { TextStyleProps as TextStyleProps_2 } from '@antv/gui/lib/shapes';
import type { TimebarStyleProps } from '@antv/gui';
import { TreeData as TreeData_2 } from '@antv/graphlib';

// @public (undocumented)
export interface AnimateCfg {
    callback?: () => void;
    delay?: number;
    duration?: number;
    easing?: string;
    iterations?: number | typeof Infinity;
    pauseCallback?: () => void;
    resumeCallback?: () => void;
}

// @public (undocumented)
export type AnimateTiming = 'buildIn' | 'buildOut' | 'show' | 'hide' | 'update';

// @public
export abstract class Behavior {
    constructor(options: any);
    // (undocumented)
    destroy(): void;
    // (undocumented)
    abstract getEvents(): {
        [eventName: string]: (event: IG6GraphEvent) => void;
    };
    // (undocumented)
    graph: Graph;
    // (undocumented)
    options: any;
    // (undocumented)
    static type: string;
    // (undocumented)
    updateConfig: (options: any) => void;
}

// @public
export type BehaviorOptionsOf<B extends BehaviorRegistry = {}> = Extract<keyof B, string> | {
    [K in keyof B]: B[K] extends {
        new (options: infer O): any;
    } ? {
        type: K;
        key: string;
    } & O : {
        type: K;
        key: string;
    };
}[Extract<keyof B, string>];

// @public
export interface BehaviorRegistry {
    // (undocumented)
    [type: string]: typeof Behavior;
}

// @public
export type ComboDisplayModel = Node_2<ComboDisplayModelData>;

// @public (undocumented)
export type ComboLabelPosition = 'bottom' | 'center' | 'top' | 'left' | 'left-top' | 'right' | 'outside-top' | 'outside-left' | 'outside-right' | 'outside-bottom';

// @public
export type ComboModel = Node_2<ComboModelData>;

// @public
export interface ComboModelData extends ComboUserModelData {
    // (undocumented)
    anchorPoints?: number[][];
    // (undocumented)
    fixSize?: number | number[];
    // (undocumented)
    label?: string;
    // (undocumented)
    padding?: Padding;
    // (undocumented)
    visible?: boolean;
}

// @public (undocumented)
export interface ComboShapesEncode extends ShapesEncode {
    // (undocumented)
    anchorPoints?: number[][] | Encode<number[][]>;
    // (undocumented)
    fixSize?: number | number[] | Encode<number | number[]>;
    // (undocumented)
    labelShape?: ComboLabelShapeAttrEncode;
    // (undocumented)
    padding?: Padding | Encode<Padding>;
}

// @public (undocumented)
export interface ComboShapeStyles extends ItemShapeStyles {
    // (undocumented)
    anchorShapes?: ShapeStyle & {
        color?: string;
        textColor?: string;
        size?: number;
        offsetX?: number;
        offsetY?: number;
        offsetZ?: number;
        [key: number]: ShapeStyle & {
            position?: BadgePosition;
            color?: string;
            textColor?: string;
            size?: number;
            offsetX?: number;
            offsetY?: number;
            offsetZ?: number;
        };
    };
    // (undocumented)
    badgeShapes?: ShapeStyle & {
        color?: string;
        textColor?: string;
        palette?: string[];
        [key: number]: ShapeStyle & {
            position?: BadgePosition;
            color?: string;
            textColor?: string;
        };
    };
    // (undocumented)
    iconShape?: Partial<TextStyleProps_2 & ImageStyleProps_2 & ShapeStyle & {
        offsetX?: number;
        offsetY?: number;
        lod?: number;
        contentType?: 'auto' | 'childCount';
    }>;
    // (undocumented)
    keyShape?: ShapeStyle & {
        padding?: number | number[];
    };
    // (undocumented)
    labelBackgroundShape?: ShapeStyle & {
        padding?: number | number[];
    };
    // (undocumented)
    labelShape?: ShapeStyle & {
        position?: ComboLabelPosition;
        offsetX?: number;
        offsetY?: number;
        offsetZ?: number;
        maxWidth?: string | number;
    };
}

// @public
export type ComboUserModel = Node_2<ComboUserModelData>;

// @public (undocumented)
export type DataConfig = GraphData | InlineGraphDataConfig | InlineTreeDataConfig | FetchDataConfig;

// @public (undocumented)
const _default: {
    Graph: typeof Graph;
    Util: typeof Util;
    stdLib: {
        markers: {
            collapse: (x: any, y: any, r: any) => any[][];
            expand: (x: any, y: any, r: any) => any[][];
            upTriangle: (x: any, y: any, r: any) => any[][];
            downTriangle: (x: any, y: any, r: any) => any[][];
        };
    };
    Extensions: {
        ValidateData: (data: GraphDataChanges, options?: {}, graphCore?: GraphCore) => GraphDataChanges;
        TransformV4Data: (data: GraphDataChanges, options?: {}, graphCore?: GraphCore) => GraphDataChanges;
        MapNodeSize: (data: GraphDataChanges, options?: {
            field?: string;
            range?: [number, number];
        }, graphCore?: GraphCore) => GraphDataChanges;
        ProcessParallelEdges: (data: GraphDataChanges, options?: {
            edgeIds?: ID_3[];
            offsetDiff?: number;
            multiEdgeType?: string;
            singleEdgeType?: string;
            loopEdgeType?: string;
        }, graphCore?: GraphCore) => GraphDataChanges;
        LightTheme: ThemeSpecification;
        DarkTheme: ThemeSpecification;
        SpecThemeSolver: SpecThemeSolver;
        SubjectThemeSolver: SubjectThemeSolver;
        ForceLayout: ForceLayout_2;
        GridLayout: GridLayout_2;
        CircularLayout: CircularLayout_2;
        ConcentricLayout: ConcentricLayout_2;
        RandomLayout: RandomLayout_2;
        MDSLayout: MDSLayout_2;
        RadialLayout: RadialLayout_2;
        FruchtermanLayout: FruchtermanLayout_2;
        D3ForceLayout: D3ForceLayout_2;
        ForceAtlas2Layout: ForceAtlas2Layout;
        DagreLayout: DagreLayout;
        ComboCombinedLayout: ComboCombinedLayout;
        compactBox: any;
        dendrogram: any;
        indented: any;
        mindmap: any;
        CircleNode: CircleNode;
        RectNode: RectNode;
        DiamondNode: DiamondNode;
        DonutNode: DonutNode;
        SphereNode: SphereNode;
        StarNode: StarNode;
        HexagonNode: HexagonNode;
        TriangleNode: TriangleNode;
        EllipseNode: EllipseNode;
        ModelRectNode: ModelRectNode;
        CubeNode: CubeNode;
        PlaneNode: PlaneNode;
        BaseNode: BaseNode;
        BaseNode3D: BaseNode3D;
        LineEdge: LineEdge;
        CubicEdge: CubicEdge;
        CubicHorizontalEdge: CubicHorizontalEdge;
        CubicVerticalEdge: CubicVerticalEdge;
        LoopEdge: LoopEdge;
        PolylineEdge: PolylineEdge;
        QuadraticEdge: QuadraticEdge;
        CircleCombo: CircleCombo;
        RectCombo: RectCombo;
        BaseBehavior: Behavior;
        ActivateRelations: ActivateRelations;
        BrushSelect: BrushSelect;
        HoverActivate: HoverActivate;
        LassoSelect: LassoSelect;
        OrbitCanvas3D: OrbitCanvas3D;
        RotateCanvas3D: RotateCanvas3D;
        TrackCanvas3D: TrackCanvas3D;
        ZoomCanvas3D: ZoomCanvas3D;
        ZoomCanvas: ZoomCanvas;
        DragCanvas: DragCanvas;
        CollapseExpandTree: CollapseExpandTree;
        CollapseExpandCombo: CollapseExpandCombo;
        DragNode: DragNode;
        DragCombo: DragCombo;
        CreateEdge: CreateEdge;
        ShortcutsCall: ShortcutsCall;
        ScrollCanvas: ScrollCanvas;
        BasePlugin: PluginBase;
        History: {
            new (): History;
            prototype: History;
        };
        LodController: LodController;
        Toolbar: Toolbar;
        Tooltip: Tooltip;
        Minimap: Minimap;
        Grid: Grid;
        Menu: Menu;
        Fisheye: Fisheye;
        Legend: Legend;
        Timebar: Timebar;
        Hull: Hull;
        Snapline: Snapline;
        EdgeFilterLens: EdgeFilterLens;
        WaterMarker: WaterMarker;
        EdgeBundling: EdgeBundling;
    };
    version: string;
    register: any;
    unregister: any;
    getRegisterPlugins: any;
    getRegisterPlugin: any;
};
export default _default;

// @public (undocumented)
export type DisplayGraphCore = Graph_2<NodeDisplayModelData, EdgeDisplayModelData>;

// @public
export type EdgeDisplayModel = Edge<EdgeDisplayModelData>;

// @public (undocumented)
export type EdgeLabelPosition = 'start' | 'middle' | 'end';

// @public
export type EdgeModel = Edge<EdgeModelData>;

// @public (undocumented)
export type EdgeModelData = EdgeUserModelData;

// @public (undocumented)
export interface EdgeShapesEncode extends ShapesEncode {
    // (undocumented)
    badgeShape?: ShapeAttrEncode | Encode<ShapeStyle>;
    // (undocumented)
    labelBackgroundShape?: LabelBackground | Encode<LabelBackground>;
    // (undocumented)
    labelShape?: EdgeLabelShapeAttrEncode;
}

// @public (undocumented)
export interface EdgeShapeStyles extends ItemShapeStyles {
    // (undocumented)
    badgeShape?: ShapeStyle & {
        color?: string;
        textColor?: string;
    };
    // (undocumented)
    keyShape?: ShapeStyle & {
        startArrow?: boolean | ArrowStyle;
        endArrow?: boolean | ArrowStyle;
    };
    // (undocumented)
    labelBackgroundShape?: ShapeStyle & {
        padding?: number | number[];
    };
    // (undocumented)
    labelShape?: ShapeStyle & {
        position?: 'start' | 'middle' | 'end';
        offsetX?: number;
        offsetY?: number;
        offsetZ?: number;
        autoRotate?: boolean;
        maxWidth?: string | number;
    };
}

// @public
export type EdgeUserModel = Edge<EdgeUserModelData>;

// @public (undocumented)
export const Extensions: {
    ValidateData: (data: GraphDataChanges, options?: {}, graphCore?: GraphCore) => GraphDataChanges;
    TransformV4Data: (data: GraphDataChanges, options?: {}, graphCore?: GraphCore) => GraphDataChanges;
    MapNodeSize: (data: GraphDataChanges, options?: {
        field?: string;
        range?: [number, number];
    }, graphCore?: GraphCore) => GraphDataChanges;
    ProcessParallelEdges: (data: GraphDataChanges, options?: {
        edgeIds?: ID[];
        offsetDiff?: number;
        multiEdgeType?: string;
        singleEdgeType?: string;
        loopEdgeType?: string;
    }, graphCore?: GraphCore) => GraphDataChanges;
    LightTheme: ThemeSpecification;
    DarkTheme: ThemeSpecification;
    SpecThemeSolver: typeof ThemeSolvers.SpecThemeSolver;
    SubjectThemeSolver: typeof ThemeSolvers.SubjectThemeSolver;
    ForceLayout: typeof Layouts.ForceLayout;
    GridLayout: typeof Layouts.GridLayout;
    CircularLayout: typeof Layouts.CircularLayout;
    ConcentricLayout: typeof Layouts.ConcentricLayout;
    RandomLayout: typeof Layouts.RandomLayout;
    MDSLayout: typeof Layouts.MDSLayout;
    RadialLayout: typeof Layouts.RadialLayout;
    FruchtermanLayout: typeof Layouts.FruchtermanLayout;
    D3ForceLayout: typeof Layouts.D3ForceLayout;
    ForceAtlas2Layout: typeof Layouts.ForceAtlas2Layout;
    DagreLayout: typeof Layouts.DagreLayout;
    ComboCombinedLayout: typeof Layouts.ComboCombinedLayout;
    compactBox: any;
    dendrogram: any;
    indented: any;
    mindmap: any;
    CircleNode: typeof Nodes.CircleNode;
    RectNode: typeof Nodes.RectNode;
    DiamondNode: typeof Nodes.DiamondNode;
    DonutNode: typeof Nodes.DonutNode;
    SphereNode: typeof Nodes.SphereNode;
    StarNode: typeof Nodes.StarNode;
    HexagonNode: typeof Nodes.HexagonNode;
    TriangleNode: typeof Nodes.TriangleNode;
    EllipseNode: typeof Nodes.EllipseNode;
    ModelRectNode: typeof Nodes.ModelRectNode;
    CubeNode: typeof Nodes.CubeNode;
    PlaneNode: typeof Nodes.PlaneNode;
    BaseNode: typeof Nodes.BaseNode;
    BaseNode3D: typeof Nodes.BaseNode3D;
    LineEdge: typeof Edges.LineEdge;
    CubicEdge: typeof Edges.CubicEdge;
    CubicHorizontalEdge: typeof Edges.CubicHorizontalEdge;
    CubicVerticalEdge: typeof Edges.CubicVerticalEdge;
    LoopEdge: typeof Edges.LoopEdge;
    PolylineEdge: typeof Edges.PolylineEdge;
    QuadraticEdge: typeof Edges.QuadraticEdge;
    CircleCombo: typeof Combos.CircleCombo;
    RectCombo: typeof Combos.RectCombo;
    BaseBehavior: typeof Behavior;
    ActivateRelations: typeof Behaviors.ActivateRelations;
    BrushSelect: typeof Behaviors.BrushSelect;
    HoverActivate: typeof Behaviors.HoverActivate;
    LassoSelect: typeof Behaviors.LassoSelect;
    OrbitCanvas3D: typeof Behaviors.OrbitCanvas3D;
    RotateCanvas3D: typeof Behaviors.RotateCanvas3D;
    TrackCanvas3D: typeof Behaviors.TrackCanvas3D;
    ZoomCanvas3D: typeof Behaviors.ZoomCanvas3D;
    ZoomCanvas: typeof Behaviors.ZoomCanvas;
    DragCanvas: typeof Behaviors.DragCanvas;
    CollapseExpandTree: typeof Behaviors.CollapseExpandTree;
    CollapseExpandCombo: typeof Behaviors.CollapseExpandCombo;
    DragNode: typeof Behaviors.DragNode;
    DragCombo: typeof Behaviors.DragCombo;
    CreateEdge: typeof Behaviors.CreateEdge;
    ShortcutsCall: typeof Behaviors.ShortcutsCall;
    ScrollCanvas: typeof Behaviors.ScrollCanvas;
    BasePlugin: typeof PluginBase;
    History: {
        new (): History;
        prototype: History;
    };
    LodController: typeof Widgets.LodController;
    Toolbar: typeof Widgets.Toolbar;
    Tooltip: typeof Widgets.Tooltip;
    Minimap: typeof Widgets.Minimap;
    Grid: typeof Widgets.Grid;
    Menu: typeof Widgets.Menu;
    Fisheye: typeof Widgets.Fisheye;
    Legend: typeof Widgets.Legend;
    Timebar: typeof Widgets.Timebar;
    Hull: typeof Hull;
    Snapline: typeof Widgets.Snapline;
    EdgeFilterLens: typeof Widgets.EdgeFilterLens;
    WaterMarker: typeof WaterMarker;
    EdgeBundling: typeof Widgets.EdgeBundling;
};

// @public
const getArrowPath: (type: ArrowType, width: number, height: number) => string;

// @public
const getEdgesBetween: (graph: Graph, ids: ID[]) => ID[];

// @public (undocumented)
export const getRegisterPlugin: any;

// @public (undocumented)
export const getRegisterPlugins: any;

// @public (undocumented)
class Graph<B extends BehaviorRegistry = any, T extends ThemeSolverRegistry = any> extends EventEmitter {
    constructor(spec: Specification<B, T>);
    addBehaviors(behaviors: BehaviorOptionsOf<B> | BehaviorOptionsOf<B>[], modes: string | string[]): void;
    addCombo(model: ComboUserModel, childrenIds: ID[]): ComboModel;
    addData(itemType: ITEM_TYPE, models: NodeUserModel | EdgeUserModel | ComboUserModel | NodeUserModel[] | EdgeUserModel[] | ComboUserModel[]): NodeModel | EdgeModel | ComboModel | NodeModel[] | EdgeModel[] | ComboModel[];
    addPlugins(pluginCfgs: ({
        key: string;
        type: string;
        [cfgName: string]: unknown;
    } | string)[]): void;
    protected asyncToDataUrl(type?: DataURLType, callback?: Function): void;
    protected asyncToFullDataUrl(type?: DataURLType, imageConfig?: {
        padding?: number | number[];
    }, callback?: (dataUrl: string) => void): void;
    // (undocumented)
    backgroundCanvas: Canvas;
    backItem(ids: ID | ID[]): void;
    // (undocumented)
    canvas: Canvas;
    changeData(data: DataConfig, type?: 'replace' | 'mergeReplace', relayout?: boolean): Promise<void>;
    changeRenderer(type: any): void;
    clear(): void;
    clearItemState(ids: ID | ID[], states?: string[]): void;
    collapse(ids: ID | ID[], disableAnimate?: boolean): void;
    collapseCombo(comboIds: ID | ID[]): void;
    // (undocumented)
    container: HTMLElement;
    destroy(callback?: Function): void;
    // (undocumented)
    destroyed: boolean;
    downloadFullImage(name?: string, type?: DataURLType, imageConfig?: {
        padding?: number | number[];
    }): void;
    downloadImage(name?: string, type?: DataURLType): void;
    drawTransient(type: ITEM_TYPE | SHAPE_TYPE, id: ID, config: {
        action?: 'remove' | 'add' | 'update' | undefined;
        data?: Record<string, any>;
        style?: ShapeStyle;
        drawSource?: boolean;
        drawTarget?: boolean;
        shapeIds?: string[];
        visible?: boolean;
        upsertAncestors?: boolean;
    }, canvas?: Canvas): DisplayObject;
    expand(ids: ID | ID[], disableAnimate?: boolean): void;
    expandCombo(comboIds: ID | ID[]): void;
    findIdByState(itemType: ITEM_TYPE, state: string, value?: string | boolean, additionalFilter?: (item: NodeModel | EdgeModel | ComboModel) => boolean): ID[];
    fitCenter(boundsType?: 'render' | 'layout', effectTiming?: CameraAnimationOptions): Promise<void>;
    fitView(options?: {
        padding?: Padding;
        rules?: FitViewRules;
    }, effectTiming?: CameraAnimationOptions): Promise<void>;
    focusItem(id: ID | ID[], effectTiming?: CameraAnimationOptions): Promise<void>;
    frontItem(ids: ID | ID[]): void;
    getAllCombosData(): ComboModel[];
    getAllEdgesData(): EdgeModel[];
    getAllNodesData(): NodeModel[];
    getCanvasByClient(clientPoint: Point): Point;
    getCanvasByViewport(viewportPoint: Point): Point;
    // (undocumented)
    getCanvasRange(): Bounds;
    getClientByCanvas(canvasPoint: Point): Point;
    getComboChildrenData(comboId: ID): (ComboModel | NodeModel)[];
    getComboData(condition: ID | Function): ComboModel | undefined;
    // (undocumented)
    protected getDisplayModel(id: ID): NodeDisplayModel | EdgeDisplayModel | ComboDisplayModel;
    getEdgeData(condition: ID | Function): EdgeModel | undefined;
    getItemAllStates(id: ID): string[];
    getItemState(id: ID, state: string): string | boolean;
    getItemVisible(id: ID): boolean;
    getItemVisibleShapeIds(id: ID): any[];
    // (undocumented)
    getLayoutCurrentAnimation(): Animation_2;
    getMode(): string;
    getNearEdgesData(nodeId: ID, shouldBegin?: (edge: EdgeDisplayModel) => boolean): EdgeModel[];
    getNeighborNodesData(nodeId: ID, direction?: 'in' | 'out' | 'both'): NodeModel[];
    getNodeData(condition: ID | Function): NodeModel | undefined;
    getRelatedEdgesData(nodeId: ID, direction?: 'in' | 'out' | 'both'): EdgeModel[];
    getRenderBBox(id: ID | undefined, onlyKeyShape?: boolean, isTransient?: boolean): AABB | false;
    getSize(): number[];
    getSpecification(): Specification<B, T>;
    getTypeById(id: ID): ITEM_TYPE;
    getViewportByCanvas(canvasPoint: Point): Point;
    // (undocumented)
    getViewportCenter(): PointLike;
    getZoom(): number;
    hideItem(ids: ID | ID[], options?: {
        disableAnimate?: boolean;
        keepKeyShape?: boolean;
        keepRelated?: boolean;
        shapeIds?: string[];
    }): void;
    // (undocumented)
    hooks: Hooks;
    // (undocumented)
    labelCanvas: Canvas;
    layout(options?: Partial<LayoutOptions>, disableAnimate?: boolean): Promise<void>;
    moveCombo(ids: ID | ID[], dx: number, dy: number, upsertAncestors?: boolean, callback?: (model: NodeModel | EdgeModel | ComboModel, canceled?: boolean) => void): ComboModel[];
    read(data: DataConfig): Promise<void>;
    removeBehaviors(behaviorKeys: string[], modes: string | string[]): void;
    removeData(itemType: ITEM_TYPE, ids: ID | ID[]): void;
    removePlugins(pluginKeys: (PluginBase | string)[]): void;
    // (undocumented)
    rendererType: RendererName;
    rotate(angle: number, origin?: PointLike, effectTiming?: CameraAnimationOptions): Promise<void>;
    rotateTo(angle: number, origin?: PointLike, effectTiming?: CameraAnimationOptions): Promise<void>;
    setCursor(cursor: Cursor): void;
    setItemState(ids: ID | ID[], states: string | string[], value: boolean): void;
    setMode(mode: string): void;
    setSize(size: number[]): void;
    showItem(ids: ID | ID[], options?: {
        disableAnimate?: boolean;
        shapeIds?: string | string[];
    }): void;
    stopLayout(): void;
    stopTransformTransition(): void;
    toDataURL(type?: DataURLType): Promise<string>;
    toFullDataURL(type?: DataURLType, imageConfig?: {
        padding?: number | number[];
    }): Promise<unknown>;
    // (undocumented)
    transform(options: GraphTransformOptions, effectTiming?: CameraAnimationOptions): Promise<void>;
    // (undocumented)
    transientCanvas: Canvas;
    // (undocumented)
    transientLabelCanvas: Canvas;
    translate(distance: Partial<{
        dx: number;
        dy: number;
        dz: number;
    }>, effectTiming?: CameraAnimationOptions): Promise<void>;
    translateTo({ x, y }: Point, effectTiming?: CameraAnimationOptions): Promise<void>;
    updateBehavior(behavior: BehaviorOptionsOf<B>, mode?: string): void;
    updateComboPosition(models: Partial<NodeUserModel> | Partial<ComboUserModel | Partial<NodeUserModel>[] | Partial<ComboUserModel>[]>, upsertAncestors?: boolean, disableAnimate?: boolean, callback?: (model: NodeModel | EdgeModel | ComboModel) => void): NodeModel | ComboModel | EdgeModel | NodeModel[] | EdgeModel[] | ComboModel[];
    updateData(itemType: ITEM_TYPE, models: Partial<NodeUserModel> | Partial<EdgeUserModel> | Partial<ComboUserModel | Partial<NodeUserModel>[] | Partial<EdgeUserModel>[] | Partial<ComboUserModel>[]>): NodeModel | EdgeModel | ComboModel | NodeModel[] | EdgeModel[] | ComboModel[];
    updateMapper(type: ITEM_TYPE, mapper: NodeMapper | EdgeMapper | ComboMapper): void;
    updateNodePosition(models: Partial<NodeUserModel> | Partial<ComboUserModel | Partial<NodeUserModel>[] | Partial<ComboUserModel>[]>, upsertAncestors?: boolean, disableAnimate?: boolean, callback?: (model: NodeModel | EdgeModel | ComboModel, canceled?: boolean) => void): NodeModel | ComboModel | EdgeModel | NodeModel[] | EdgeModel[] | ComboModel[];
    updatePlugin(plugin: {
        key: string;
        type: string;
        [cfg: string]: unknown;
    } | PluginBase): void;
    updateSpecification(spec: Specification<B, T>): Specification<B, T>;
    updateStateConfig(itemType: ITEM_TYPE, stateConfig: {
        [stateName: string]: ((data: NodeModel) => NodeDisplayModel) | NodeShapesEncode;
    } | {
        [stateName: string]: ((data: EdgeModel) => EdgeDisplayModel) | EdgeShapesEncode;
    } | {
        [stateName: string]: ((data: ComboModel) => ComboDisplayModel) | ComboShapesEncode;
    }, updateType?: 'mergeReplace' | 'replace'): void;
    updateTheme(theme: ThemeOptionsOf<T>): void;
    zoom(ratio: number, origin?: Point, effectTiming?: CameraAnimationOptions): Promise<void>;
    zoomTo(zoom: number, origin?: PointLike, effectTiming?: CameraAnimationOptions): Promise<void>;
}
export { Graph }
export { Graph as IGraph }

// @public
const graphComboTreeDfs: (graph: Graph, nodes: NodeUserModel[], fn: any, mode?: 'TB' | 'BT') => void;

// @public (undocumented)
export type GraphCore = Graph_2<NodeModelData, EdgeModelData>;

// @public
const graphCoreTreeDfs: (graphCore: GraphCore, nodes: NodeUserModel[], fn: any, mode?: 'TB' | 'BT', treeKey?: string, stopFns?: {
    stopBranchFn?: (node: NodeUserModel) => boolean;
    stopAllFn?: (node: NodeUserModel) => boolean;
}) => void;

// @public (undocumented)
export interface GraphData {
    // (undocumented)
    combos?: ComboUserModel[];
    // (undocumented)
    edges?: EdgeUserModel[];
    // (undocumented)
    nodes?: NodeUserModel[];
}

// @public
const graphData2TreeData: (nodeMap: {
    [id: string]: any;
}, graphData: GraphData, propRootIds?: ID[]) => any[];

// @public (undocumented)
export interface IAnimate {
    // (undocumented)
    delay?: number;
    // (undocumented)
    duration?: number;
    // (undocumented)
    easing?: string;
    // (undocumented)
    fields?: string[];
    // (undocumented)
    iterations?: number;
    // (undocumented)
    order?: number;
    // (undocumented)
    shapeId?: string;
}

// @public (undocumented)
export interface IAnimates {
    // (undocumented)
    buildIn?: IAnimate[];
    // (undocumented)
    buildOut?: IAnimate[];
    // (undocumented)
    hide?: IAnimate[];
    // (undocumented)
    show?: IAnimate[];
    // (undocumented)
    update?: (IAnimate | IStateAnimate)[];
}

// @public
export type ICanvasEventType = `${CANVAS_EVENT_TYPE}`;

export { ID }

// @public (undocumented)
export interface IG6GraphEvent extends Omit<FederatedPointerEvent, 'currentTarget'> {
    // (undocumented)
    currentTarget: Graph;
    gEvent: Event;
    // (undocumented)
    itemId: ID;
    // (undocumented)
    itemType: 'node' | 'edge' | 'combo' | 'canvas';
    // (undocumented)
    key?: string;
}

// @public (undocumented)
export type ImmediatelyInvokedLayoutOptions = {
    execute: (graph: GraphCore, options?: any) => Promise<LayoutMapping>;
} & Animatable_2 & PresetLayoutOptions;

// @public (undocumented)
export interface IPluginBaseConfig {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    className?: string;
    // (undocumented)
    container?: HTMLElement | string | null;
    // (undocumented)
    graph?: Graph;
}

// @public
const isEncode: (value: any) => value is Encode<any>;

// @internal (undocumented)
export function isImmediatelyInvokedLayoutOptions(options: any): options is ImmediatelyInvokedLayoutOptions;

// @internal (undocumented)
export function isLayoutWorkerized(options: STDLayoutOptions): boolean;

// @public
const isSucceed: (graph: any, testParent: any, testSucceed: any) => boolean;

// @public (undocumented)
export type LayoutOptions = STDLayoutOptions | ImmediatelyInvokedLayoutOptions;

// @public
const mock: (nodeCount: number) => {
    circle: (centerId?: string) => {
        nodes: {
            id: string;
            data: {};
        }[];
        edges: any[];
    };
    random: (ratio?: number) => {
        nodes: {
            id: string;
            data: {};
        }[];
        edges: any[];
    };
};

// @public
export type NodeDisplayModel = Node_2<NodeDisplayModelData>;

// @public (undocumented)
export interface NodeEncode extends NodeShapesEncode {
    // (undocumented)
    animates?: IAnimates;
    // (undocumented)
    lodLevels?: LodLevel[];
    // (undocumented)
    type?: string | Encode<string>;
}

// @public (undocumented)
export type NodeLabelPosition = 'bottom' | 'center' | 'top' | 'left' | 'right';

// @public
export type NodeModel = Node_2<NodeModelData>;

// @public
export type NodeModelData = NodeUserModelData;

// @public (undocumented)
export interface NodeShapesEncode extends ShapesEncode {
    // (undocumented)
    anchorShapes?: ShapeAttrEncode[] | Encode<ShapeStyle[]>;
    // (undocumented)
    badgeShapes?: ShapeAttrEncode[] | Encode<ShapeStyle[]>;
    // (undocumented)
    labelBackgroundShape?: ShapeAttrEncode[] | Encode<ShapeStyle[]>;
    // (undocumented)
    labelShape?: NodeLabelShapeAttrEncode | Encode<ShapeStyle>;
}

// @public (undocumented)
export interface NodeShapeStyles extends ItemShapeStyles {
    // (undocumented)
    anchorShapes?: ShapeStyle & {
        [key: number]: ShapeStyle & {
            position?: 'top' | 'left' | 'bottom' | 'right' | [number, number];
        };
    };
    badgeShapes?: ShapeStyle & {
        color?: string;
        palette?: string[];
        textColor?: string;
        [key: number]: ShapeStyle & {
            position?: IBadgePosition;
            color?: string;
            textColor?: string;
        };
    };
    labelBackgroundShape?: ShapeStyle & {
        padding?: number | number[];
    };
    labelShape?: ShapeStyle & {
        position?: 'top' | 'bottom' | 'left' | 'right' | 'center';
        offsetX?: number;
        offsetY?: number;
        offsetZ?: number;
        maxWidth?: string | number;
        angle?: number;
    };
}

// @public
export type NodeUserModel = Node_2<NodeUserModelData>;

// @public (undocumented)
export abstract class PluginBase {
    constructor(options?: IPluginBaseConfig);
    destroy(): void;
    // (undocumented)
    destroyed: boolean;
    getDefaultCfgs(): {};
    getEvents(): {};
    // (undocumented)
    graph: Graph;
    init(graph: Graph): void;
    // (undocumented)
    key: string;
    // (undocumented)
    options: IPluginBaseConfig;
    // (undocumented)
    static required: boolean;
    // (undocumented)
    static type: string;
    updateCfgs(options?: IPluginBaseConfig): void;
}

// @public (undocumented)
export type Point = {
    x: number;
    y: number;
    z?: number;
};

// @public (undocumented)
export const register: any;

// @public (undocumented)
export interface Specification<B extends BehaviorRegistry, T extends ThemeSolverRegistry> {
    animate?: AnimateCfg;
    // (undocumented)
    autoFit?: 'view' | 'center' | {
        type: 'view';
        padding?: Padding;
        rules?: FitViewRules;
        effectTiming?: CameraAnimationOptions;
    } | {
        type: 'center';
        effectTiming?: CameraAnimationOptions;
    } | {
        type: 'position';
        position: Point;
        alignment?: GraphAlignment;
        effectTiming?: CameraAnimationOptions;
    };
    // (undocumented)
    backgroundCanvas?: Canvas;
    // (undocumented)
    canvas?: Canvas;
    // (undocumented)
    combo?: ComboMapper;
    // (undocumented)
    comboState?: {
        [stateName: string]: ((data: ComboModel) => ComboDisplayModel) | ComboShapesEncode;
    };
    // (undocumented)
    container?: string | HTMLElement;
    data?: DataConfig;
    // (undocumented)
    edge?: EdgeMapper;
    // (undocumented)
    edgeState?: {
        [stateName: string]: ((data: EdgeModel) => EdgeDisplayModel) | EdgeShapesEncode;
    };
    // (undocumented)
    height?: number;
    // (undocumented)
    labelCanvas?: Canvas;
    layout?: LayoutOptions | LayoutOptions[];
    // (undocumented)
    mode?: 'default' | string;
    modes?: {
        [mode: string]: BehaviorOptionsOf<B>[];
    };
    node?: NodeMapper;
    nodeState?: {
        [stateName: string]: ((data: NodeModel) => NodeDisplayModel) | NodeShapesEncode;
    };
    optimize?: {
        tileFirstRender?: boolean | number;
        tileFirstRenderSize?: number;
        tileBehavior?: boolean | number;
        tileBehaviorSize?: number;
        tileLodSize?: number;
    };
    plugins?: (string | {
        key: string;
        type: string;
        [cfgName: string]: unknown;
    } | PluginBase)[];
    // (undocumented)
    renderer?: RendererName | {
        type: RendererName;
        pixelRatio: number;
        headless: boolean;
    };
    theme?: ThemeOptionsOf<T>;
    // (undocumented)
    transforms?: string[] | {
        type: string;
        activeLifecycle: 'all' | DataLifecycleType | DataLifecycleType[];
        [param: string]: unknown;
    }[] | TransformerFn[];
    // (undocumented)
    transientCanvas?: Canvas;
    // (undocumented)
    transientLabelCanvas?: Canvas;
    // (undocumented)
    width?: number;
    // (undocumented)
    zoom?: number;
}

// @public (undocumented)
export type STDLayoutOptions = BuiltInLayoutOptions & Animatable_2 & Workerized & PresetLayoutOptions;

// @public (undocumented)
export const stdLib: {
    markers: {
        collapse: (x: any, y: any, r: any) => any[][];
        expand: (x: any, y: any, r: any) => any[][];
        upTriangle: (x: any, y: any, r: any) => any[][];
        downTriangle: (x: any, y: any, r: any) => any[][];
    };
};

// @public
export interface ThemeSpecification {
    // (undocumented)
    canvas?: {
        [cssName: string]: unknown;
    };
    // (undocumented)
    combo?: ComboThemeSpecifications;
    // (undocumented)
    edge?: EdgeThemeSpecifications;
    // (undocumented)
    node?: NodeThemeSpecifications;
    // (undocumented)
    type?: string;
}

// @public
function transform(m: number[], actions: any[][]): any[];

// @public
const traverse: (treeData: any, callback: any) => void;

// @public
const traverseAncestors: (graphCore: any, nodes: any, fn: any) => void;

// @public
const traverseAncestorsAndSucceeds: (graph: Graph, graphCore: GraphCore, nodes: NodeUserModel[], fn: any, mode?: 'TB' | 'BT') => void;

// @public (undocumented)
const traverseGraphAncestors: (graph: Graph, nodes: NodeUserModel[], fn: any) => void;

// @public (undocumented)
export type TreeData = TreeData_2<NodeUserModelData> | TreeData_2<NodeUserModelData>[];

// @public
const treeData2GraphData: (treeData: TreeData_2<NodeUserModelData> | TreeData_2<NodeUserModelData>[]) => {
    nodes: any[];
    edges: any[];
    combos: any[];
};

// @public (undocumented)
export const unregister: any;

declare namespace Util {
    export {
        getArrowPath,
        graphComboTreeDfs,
        graphCoreTreeDfs,
        graphData2TreeData,
        isSucceed,
        traverse,
        traverseAncestors,
        traverseAncestorsAndSucceeds,
        traverseGraphAncestors,
        treeData2GraphData,
        getEdgesBetween,
        transform,
        mock,
        isEncode
    }
}
export { Util }

// @public
export const version = "5.0.0";

```
